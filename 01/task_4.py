"""
Задание 4.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Пользователи веб-ресурса проходят аутентификацию.
В системе хранятся логин, пароль и отметка об активации учетной записи.

Нужно реализовать проверку, может ли пользователь быть допущен к ресурсу.
При этом его учетка должна быть активирована.
А если нет, то польз-лю нужно предложить ее пройти.

Приложение должно давать ответы на эти вопросы и быть реализовано в виде функции.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
"""

auth_my_web = {'Ann': ['123', True], 'Ben': ['234', False]}


def check_auth_info(auth_dict):
    login_name = input('Enter your login: ')
    passw = input('Enter your password: ')
    check_login = auth_dict.get(login_name, 'Invalid login')
    if check_login[0] == passw and check_login[1]:
        print("Enter to my web-site")
    elif check_login[0] == passw and not check_login[1]:
        print("Do you want to active your account?")
        to_active = input("If you want to active your account, enter - y\nelse enter - n: ")
        if to_active == 'y':
            print("instructions to activate account")
        else:
            print("other instructions")
    else:
        print('Error: Invalid login or/and password')


check_auth_info(auth_my_web)

"""
Сложность алгоритма, если я всё правильно поняла, получилась
константная O(1), самой функции.
Так как циклов и переборов там нет, всё, что сравнивается,
берется по индексу.
Остается только сложность наполнения словаря, но он есть в любом случае,
поэтому его в расчет не беру.

Если я правильно оценила сложность, то алгоритм достаточно хороший и
эффективный
"""
